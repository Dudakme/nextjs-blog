# TL;DR  
코드업 문제집에서 '탐색기반설계' 라는 말을 만나 어떤 말인지 궁금해 조사하여 정리해보았다.  
>**참고문헌**
>- [탐색공간의 배제(Exclusion of Search Space)](https://lemidia.github.io/algorithm/%ED%83%90%EC%83%89%EA%B3%B5%EA%B0%84%EC%9D%98-%EB%B0%B0%EC%A0%9C/)

---

# 탐색기반설계, 관계기반설계가 뭔데? 🤔
정보과학에서는 알고리즘을 크게 두가지 방법을 통해 설계하는데, 바로 **탐색기반설계**와 **관계기반설게**이다.  

## 1. 탐색기반설계
탐색 기반 설계는 **컴퓨터의 빠른 연산을 이용하여 짧은 시간안에 가능한 해 집합을 모두 탐색**하면서 해를 구하는 방법이다.  
짧은 시간안에 가능한 해 집합을 모두 탐색하기 위해 **배제**를 통해 탐색시간을 줄인다.

### a. 경험적 배제
경험적 배제는 전체탐색법을 기본으로한 알고리즘 설계 방법이다.  
처음 시작은 전체탐색과 마찬가지로 해가 될 수 있는 모든 공간을 탐색해 나간다. 차이점이라면 특정 조건을 두고 계속 탐색 할지 여부를 정한다. **즉, 더 탐색해도 해를 발견할 가능성이 없다면 탐색을 멈춘다.**

이 조건의 설정은 알고리즘이 시작될 때는 정할 수 없고, 탐색을 진행하는 중에 조건을 설정하고, 탐색한 영역이 넓어질수록 상황에 따라 조건이 갱신된다. 따라서 탐색한 정보, 즉 경험한 정보를 이용해서 배제할 조건을 정하기 때문에 경험적 배제라고 한다.

![](./images/graph.png)

다음과 같은 그래프를 예시로 보자. 각 번호는 탐색하는 순서를 의미한다.  
만약 3번 노드가 문제의 조건을 만족한다면, 우리는 4, 5, ... 의 5개 노드를 탐색할 필요가 없어진다. 11개의 노드를 탐색해야 했던것이 6개의 노드만 탐색하면 되는 것 이다.  

**즉, Bounding(=Cutting)을 통해 연산 횟수를 줄일 수 있다.**

### b. 수학적 배제
탐색 공간 중 배제할 영역을 수학적 증명으로 결정하는 방법이다. 대표적인 예시로는 '이분탐색 알고리즘'을 들 수 있다.  
수학적 배제로 알고리즘을 설계할 경우, 공간을 배제할 원리를 수학적으로 증명한 후, 이 방법을 반복적으로 해를 찾을 때까지 적용해 나가며 해를 찾는다.  

수학적 배제의 방법으로 다음 문제를 푸는 알고리즘을 설계해보자.
>{"한 정수 n을 입력받아서 n의 모든 약수의 합을 구하는 프로그램을 작성하시오. (단, 1 <= n <= 100억)"}

문제를 풀기 위해 간단히 예를 들어 n을 10으로 놓자.  
10의 약수는 `1, 2, 5, 10` 이다. 여기서 약수의 규칙을 발견 할 수 있다.  
**1과 10은 10의 약수일 수 밖에 없다. 그리고 양끝에서 부터 짝지었을때 `(1, 10)`, `(2, 5)`는 모두 곱이 10으로 나타난다.**

즉, n의 약수를 구하기 위해 `sqrt(n)`까지 탐색하고 특정 약수 `i`에 대응하는 약수는 `n/i`로 구하면 된다.
```c
#include <math.h>
#include <stdio.h>

int getSum(int n) {
	int sum=1+n;
	for(int i=2; i<sqrt(n); i++)
		if(!(n%i))
			sum+=i+n/i;
	if(sqrt(n)*sqrt(n)==n)
		sum+=sqrt(n);
	return sum;
}

int main(void) {
	int n;
	scanf("%d", &n);
	printf("%d", getSum(n));
}
```

